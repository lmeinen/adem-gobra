// -gobra
// ##(--onlyFilesWithHeader)
package vfy

import (
	"github.com/adem-wg/adem-proto/pkg/tokens"
	"github.com/lestrrat-go/jwx/v2/jwt"

    . "lib"

	. "fact"
    . "iospec"
)


// #################################################################
// ##### Failed to derive constraints for new endorsement path #####
// #################################################################

ghost
pure func PathTrigger(_ int) bool { return true }

ghost
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
requires acc(ValidToken(emblem), 1/2) && Emblem(emblem)
requires acc(endorsements, 1/2)
requires forall i int :: { TokenListElem(i, endorsements[i]) } 0 <= i && i < len(endorsements) ==> acc(TokenListElem(i, endorsements[i]), 1/2)
requires forall i int :: { endorsements[i] } 0 <= i && i < len(endorsements) ==> emblem != endorsements[i]
decreases len(path)
pure func EndorsementPath(path seq[int], emblem *ADEMToken, endorsements []*ADEMToken) bool {
	return forall i int :: { PathTrigger(i) } 0 <= i && i < len(path) ==> (
		let idx0 := path[i] in
	 			0 <= idx0 && idx0 < len(endorsements) &&
				let t0 := endorsements[idx0] in
				i < len(path) - 1 ?
					let idx1 := path[i + 1] in
	 				0 <= idx1 && idx1 < len(endorsements) &&
					let t1 := endorsements[idx1] in (
	 					unfolding acc(TokenListElem(idx0, t0), 1/4) in
	 					unfolding acc(TokenListElem(idx1, t1), 1/4) in
	 					t0.Endorses(t1)) :
	 			unfolding acc(TokenListElem(idx0, t0), 1/4) in
				t0.Endorses(emblem))
}

ghost
trusted
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
requires acc(ValidToken(emblem), 1/2) && Emblem(emblem)
requires acc(endorsements, 1/2)
requires forall i int :: { TokenListElem(i, endorsements[i]) } 0 <= i && i < len(endorsements) ==> acc(TokenListElem(i, endorsements[i]), 1/2)
requires forall i int :: { endorsements[i] } 0 <= i && i < len(endorsements) ==> emblem != endorsements[i]
requires EndorsementPath(endorsementChain, emblem, endorsements)
requires 0 <= lastIdx && lastIdx < len(endorsements) &&
	unfolding acc(TokenListElem(lastIdx, endorsements[lastIdx]), 1/4) in  
	len(endorsementChain) == 0 ? 
		endorsements[lastIdx].Endorses(emblem) : 
	PathTrigger(0) &&
	unfolding acc(TokenListElem(endorsementChain[0], endorsements[endorsementChain[0]]), 1/4) in
	endorsements[lastIdx].Endorses(endorsements[endorsementChain[0]])
ensures acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
ensures acc(ValidToken(emblem), 1/2) && Emblem(emblem)
ensures acc(endorsements, 1/2)
ensures forall i int :: { TokenListElem(i, endorsements[i]) } 0 <= i && i < len(endorsements) ==> acc(TokenListElem(i, endorsements[i]), 1/2)
ensures forall i int :: { endorsements[i] } 0 <= i && i < len(endorsements) ==> emblem != endorsements[i]
ensures newEndorsementChain == seq[int] { lastIdx } ++ endorsementChain
ensures EndorsementPath(newEndorsementChain, emblem, endorsements)
func DeriveNewEndorsementPath(endorsementChain seq[int], lastIdx int, emblem *ADEMToken, endorsements []*ADEMToken) (newEndorsementChain seq[int]) {
	newEndorsementChain := seq[int] { lastIdx } ++ endorsementChain
	assert newEndorsementChain[1:] == endorsementChain
	assert EndorsementPath(newEndorsementChain[1:], emblem, endorsements)
	return newEndorsementChain
}


// ##########################################################
// ##### Incomplete axiomatization of slice cardinality #####
// ##########################################################

ghost
ensures len(ts) == len(fs)
ensures forall i int :: 0 <= i && i < len(fs) ==> ValidTokenIn_Verifier(rid, ts[i]) == fs[i]
pure func FactSeq(rid Term, ts seq[Term]) (fs seq[Fact])

ghost
pure func InFacts(rid Term, tokens seq[Term], used seq[Term], s mset[Fact]) bool {
	return forall i int :: { tokens[i] } 0 <= i && i < len(tokens) ==> (ValidTokenIn_Verifier(rid, tokens[i]) # FactSeq(rid, tokens)) - (ValidTokenIn_Verifier(rid, tokens[i]) # FactSeq(rid, used)) <= ValidTokenIn_Verifier(rid, tokens[i]) # s
}

ghost
requires InFacts(rid, tokens, used, s)
requires t # tokens == 2 && t # used == 0
func InFactsExample(rid, t Term, s mset[Fact], tokens, used seq[Term]) {
	assert InFacts(rid, tokens, used, s)
	s = s setminus mset[Fact] {ValidTokenIn_Verifier(rid, t)}
	used = used ++ seq[Term] { t }

	// fails
	assert InFacts(rid, tokens, used, s)
}


// #################################################################################################
// ##### Derive cardinality constraints despite limited axiomatization of slices and multisets #####
// #################################################################################################

ghost
requires 0 < len(endTs)
requires 0 <= i0 && i0 < len(endTs)
requires forall i int :: { endTs[i] } 0 <= i && i0 <= i && i < len(endTs) ==> endTs[i] # endTs[i0:] <= ValidTokenIn_Verifier(ridT, endTs[i]) # s0
func foo(endTs seq[Term], ridT Term, s0 mset[Fact], i0 int, authT Term) {
    eT := endTs[i0]
    s1 := ((s0 setminus mset[Fact] { ValidTokenIn_Verifier(ridT, eT) }) union mset[Fact] { OutFact_Verifier(ridT, EndorsedOut(authT)) })

    // Passes
    assert forall i int :: { endTs[i] } 0 <= i && i0 <= i && i < len(endTs) ==> endTs[i] # endTs[i0:] <= ValidTokenIn_Verifier(ridT, endTs[i]) # s0

    // Passes
    assert s1 == ((s0 setminus mset[Fact] { ValidTokenIn_Verifier(ridT, eT) }) union mset[Fact] { OutFact_Verifier(ridT, EndorsedOut(authT)) })

    // Passes
    assert eT == endTs[i0]

    // forall introduction
    arbI := getArbInt()
    if 0 <= arbI && i0 <= arbI && arbI < len(endTs) {
        assert endTs[arbI] # endTs[i0:] <= ValidTokenIn_Verifier(ridT, endTs[arbI]) # s0

        if ValidTokenIn_Verifier(ridT, endTs[arbI]) in s0 && arbI == i0 {
            // assert (ValidTokenIn_Verifier(ridT, endTs[arbI]) # s1) == (ValidTokenIn_Verifier(ridT, endTs[arbI]) # s0) - 1
        } else if !(ValidTokenIn_Verifier(ridT, endTs[arbI]) in s0) {
            // the following assertion is necessary!
            assert !(endTs[arbI] in endTs[i0:])
            // we can now derive a contradiction:
            assert false
        } else {
            if endTs[arbI] == endTs[i0] {
                // the following assertion is necessary!
                assert endTs[i0:] == seq[Term]{ endTs[arbI] } ++ endTs[i0+1:]
            } else {
                // the following assertion is necessary!
                assert endTs[i0:] == seq[Term]{ endTs[i0] } ++ endTs[i0+1:]
            }
        }

        if i0 < arbI {
            assert endTs[arbI] # endTs[i0+1:] <= ValidTokenIn_Verifier(ridT, endTs[arbI]) # s1
        }
    }
    // show that it holds for an arbitrary i and then assume it:
    assert 0 <= arbI && i0 < arbI && arbI < len(endTs) ==> endTs[arbI] # endTs[i0+1:] <= ValidTokenIn_Verifier(ridT, endTs[arbI]) # s1
    assume forall i int :: { endTs[i] } 0 <= i && i0 < i && i < len(endTs) ==> endTs[i] # endTs[i0+1:] <= ValidTokenIn_Verifier(ridT, endTs[i]) # s1

    // Fails
    // assert forall i int :: { endTs[i] } 0 <= i && i0 < i && i < len(endTs) ==> endTs[i] # endTs[i:] <= ValidTokenIn_Verifier(ridT, endTs[i]) # s1
}

func getArbInt() int