// +gobra
// ##(--onlyFilesWithHeader)
package vfy

import (
	"sync"

	"github.com/adem-wg/adem-proto/pkg/consts"
	"github.com/adem-wg/adem-proto/pkg/tokens"
	"github.com/adem-wg/adem-proto/pkg/roots"
	. "lib"
	"github.com/lestrrat-go/jwx/v2/jwa"
	"github.com/lestrrat-go/jwx/v2/jwk"
	"github.com/lestrrat-go/jwx/v2/jwt"

	"fact"
	"place"
	"iospec"
	"pub"
	"claim"
	"term"
)

pred SingleUse(loc *int) {
	acc(loc)
}

pred ResultPerm(result *TokenVerificationResult) {
	acc(result) &&
			(result.err == nil ==> (
				result.token != nil &&
				ValidToken(result.token) &&
				let fields := (unfolding ValidToken(result.token) in result.token.Token.Values()) in
				acc(jwt.FieldMem(fields), 1/2))) &&
			(result.err != nil ==> result.token == nil)
}

pred SendToken(loc *int, threadCount int, result *TokenVerificationResult) {
	threadCount > 0 && acc(SingleUse(loc), 1 / threadCount) && ResultPerm(result)
}

pred ResultsInv(loc *int, threadCount int, results chan *TokenVerificationResult) {
	threadCount > 0 &&
	acc(results.SendChannel(), perm(1/2)) &&
	results.SendGivenPerm() == SendToken!<loc, threadCount, _!> &&
	results.SendGotPerm() == PredTrue!<!> &&
	SingleUse(loc)
}

pred SendFraction(results chan *TokenVerificationResult, n int) {
	0 < n && acc(results.SendChannel(), 1 / (2 * n))
}

pred VfyWg(wg *sync.WaitGroup, n int, results chan *TokenVerificationResult, ghost fractionSeq seq[pred()]) {
	n > 0 &&
	wg.WaitGroupP() &&
	wg.WaitMode() &&
	len(fractionSeq) == n &&
	forall i int :: { fractionSeq[i] } 0 <= i && i < len(fractionSeq) ==> (
		fractionSeq[i] == SendFraction!<results, n!> &&
		wg.TokenById(fractionSeq[i], i))
}

pred PkgMem() {
	ErrTokenNonCompact != nil &&
	ErrNoKeyFound != nil &&
	ErrRootKeyUnbound != nil &&
	ErrAlgsDiffer != nil
}

pred PkgMems() {
	PkgMem() &&
	roots.PkgMem() &&
	acc(tokens.PkgMem(), _) &&
	acc(&jwt.Custom, _) &&
		acc(jwt.Custom, _) &&
		tokens.CustomFields(jwt.Custom)
}

ghost
requires n > 0
requires acc(wg.UnitDebt(PredTrue!<!>), n)
ensures n == old(n)
ensures len(fractionSeq) == n &&
	forall i int :: { fractionSeq[i] } 0 <= i && i < n ==> (
		fractionSeq[i] == SendFraction!<results, n!> &&
		wg.TokenById(fractionSeq[i], i))
ensures acc(wg.UnitDebt(SendFraction!<results, n!>), n)
decreases _
func generateTokenSeq(wg *sync.WaitGroup, n int, results chan *TokenVerificationResult) (fractionSeq seq[pred()]) {
	fractionSeq := seq[pred()] {}
	invariant 0 <= i && i <= n
	invariant acc(wg.UnitDebt(PredTrue!<!>), n - i)
	invariant acc(wg.UnitDebt(SendFraction!<results, n!>), i)
	invariant len(fractionSeq) == i &&
		forall j int :: { fractionSeq[j] } 0 <= j && j < i ==> (
			fractionSeq[j] == SendFraction!<results, n!> &&
			wg.TokenById(fractionSeq[j], j))
	for i := 0; i < n; i++ {
		ghost sendFraction := SendFraction!<results, n!>
		wg.GenerateTokenAndDebt(sendFraction)
		fold wg.TokenById(sendFraction, len(fractionSeq))
		fractionSeq = fractionSeq ++ seq[pred()] { sendFraction }
	}
}

ghost
requires n > 0
requires len(fractionSeq) == n &&
	forall i int :: { fractionSeq[i] } 0 <= i && i < n ==> (
		sync.InjEval(fractionSeq[i], i) &&
		fractionSeq[i] == SendFraction!<results, n!>)
ensures acc(results.SendChannel(), 1/2)
decreases _
func collectDebt(fractionSeq seq[pred()], n int, results chan *TokenVerificationResult) {
	invariant 0 <= i && i <= n
	invariant forall j int :: { fractionSeq[j] } i <= j && j < n ==> sync.InjEval(fractionSeq[j], j)
	invariant acc(results.SendChannel(), i / (2 * n))
	for i := 0; i < n; i++ {
		unfold sync.InjEval(fractionSeq[i], i)
		unfold SendFraction!<results, n!>()
	}
}

ghost
requires tokenP > 0 && acc(rawToken, tokenP)
requires place.token(p) && iospec.e_InFact(p, ridT)
ensures acc(rawToken, tokenP)
ensures gamma(tokenT) == AbsBytes(rawToken)
ensures tokenT == old(iospec.get_e_InFact_r1(p, ridT))
ensures place.token(pp) && pp == old(iospec.get_e_InFact_placeDst(p, ridT))
decreases  _
func tokenIn(rawToken []byte, ghost tokenP perm, ghost p place.Place, ghost ridT term.Term) (ghost tokenT term.Term, ghost pp place.Place) {
	tokenT := iospec.get_e_InFact_r1(p, ridT)
	assume gamma(tokenT) == AbsBytes(rawToken)
	pp := iospec.get_e_InFact_placeDst(p, ridT)
	inhale place.token(pp)
	return tokenT, pp
}

pred ValidationPerm(ghost t term.Term)

ghost
requires place.token(p) && iospec.e_PermitTokenVerificationOut(p, rid, t)
ensures pp == old(iospec.get_e_PermitTokenVerificationOut_placeDst(p, rid, t)) && place.token(pp)
ensures ValidationPerm(t)
decreases _
func permissionOut(ghost p place.Place, ghost rid term.Term, ghost t term.Term) (ghost pp place.Place) {
	exhale place.token(p)
	pp := iospec.get_e_PermitTokenVerificationOut_placeDst(p, rid, t)
	inhale place.token(pp)
	inhale ValidationPerm(t)
}

ghost
requires place.token(p) && iospec.e_PermitTokenVerificationIn(p, rid)
requires ValidationPerm(t) // TODO: Do we need this at all for the soundness argument?
ensures gamma(t) == gamma(tt)
ensures tt == old(iospec.get_e_PermitTokenVerificationIn_r1(p, rid))
ensures pp == old(iospec.get_e_PermitTokenVerificationIn_placeDst(p, rid)) && place.token(pp)
decreases _
func permissionIn(ghost t term.Term, ghost p place.Place, ghost rid term.Term) (ghost tt term.Term, ghost pp place.Place) {
	tt := iospec.get_e_PermitTokenVerificationIn_r1(p, rid)
	assume gamma(t) == gamma(tt)
	pp := iospec.get_e_PermitTokenVerificationIn_placeDst(p, rid)
	inhale place.token(pp)
	return tt, pp
}

pred ConsoleOut(ghost t term.Term)

ghost
requires place.token(p) && iospec.e_OutFact(p, rid, t)
ensures pp == old(iospec.get_e_OutFact_placeDst(p, rid, t)) && place.token(pp)
ensures ConsoleOut(t)
decreases _
func seclevelOut(ghost p place.Place, ghost rid term.Term, ghost t term.Term) (ghost pp place.Place) {
	exhale place.token(p)
	pp := iospec.get_e_OutFact_placeDst(p, rid, t)
	inhale place.token(pp)
	inhale ConsoleOut(t)
}

ghost
preserves acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
preserves ValidToken(emblem) && Emblem(emblem)
preserves ValidToken(root) && Endorsement(root)
preserves root != emblem
preserves gamma(rootT) == Abs(root) && gamma(embT) == Abs(emblem)
preserves unfolding ValidToken(emblem) in 
	unfolding acc(jwt.FieldMem(emblem.Token.Values()), 1/8) in
		emblem.Headers.ContentType() == string(consts.EmblemCty) && 
		emblem.Token.Contains("ass") && 
		emblem.Headers.Algorithm() != jwa.NoSignature && 
		emblem.Token.Issuer() != "" &&
	unfolding ValidToken(root) in 
		root.Token.Contains("log") && 
		root.Token.Contains("key") && 
		root.Token.Issuer() == emblem.Token.Issuer() && 
		root.Token.Subject() == root.Token.Issuer()
requires iospec.P_Verifier(p, rid, s) && place.token(p) && fact.St_Verifier_2(rid) in s
ensures iospec.P_Verifier(p0, rid, s0) && 
	place.token(p0) && 
	fact.St_Verifier_4(rid, oiT, rootKeyT) in s0 && 
	fact.OutFact_Verifier(rid, SignedOut(aiT)) in s0 && 
	fact.OutFact_Verifier(rid, OrganizationalOut(aiT, oiT)) in s0
ensures unfolding ValidToken(root) in 
	gamma(rootKeyT) == stringB(root.VerificationKey.KeyID(none[perm])) &&
	gamma(oiT) == stringB(root.Token.Issuer())
func GetOrganizationalOut(emblem, root *ADEMToken, p place.Place, s mset[fact.Fact], rid, rootT, embT term.Term) (p0 place.Place, s0 mset[fact.Fact], oiT, rootKeyT, aiT term.Term) {
	// TODO: (lmeinen) Drop assumption
	// Simplification: Assume root directly endorses emblem
	assume root.Endorses(emblem)

	assume fact.ValidTokenIn_Verifier(rid, rootT) in s

	ghost var endorsedKeyT term.Term
	p, s, oiT, rootKeyT, endorsedKeyT = ApplyIsOrganizationalEmblem(emblem, root, p, s, rid, rootT)

	// Loop over internal endorsements
	// orgIdx, p, s, endorsedKeyT = WalkEndorsementChain(emblem, endorsements, endorsementChain, set[int] {}, endTs, p, s, ridT, embT, rootKeyT, oiT, endorsedKeyT)

	assume fact.ValidTokenIn_Verifier(rid, embT) in s

	p, s, aiT = ApplyCollectAuthorityEndorsements(emblem, p, s, rid, embT, rootKeyT, oiT, endorsedKeyT)

	return p, s, oiT, rootKeyT, aiT
}

ghost
preserves acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
preserves acc(ValidToken(emblem), 1/2) && Emblem(emblem)
preserves acc(ValidToken(root), 3/4) && Endorsement(root)
preserves unfolding acc(ValidToken(emblem), 1/2) in 
	unfolding acc(ValidToken(root), 3/4) in 
	emblem.Token.Issuer() != "" && 
	root.Token.Contains("log") && 
	root.Token.Contains("key") && 
	root.Token.Issuer() == emblem.Token.Issuer() && 
	root.Token.Subject() == root.Token.Issuer()
preserves gamma(rootT) == Abs(root)
requires iospec.P_Verifier(p, ridT, s) && place.token(p) && fact.St_Verifier_2(ridT) in s && fact.ValidTokenIn_Verifier(ridT, rootT) in s
ensures gamma(oiT) == unfolding acc(ValidToken(emblem), 1/2) in stringB(emblem.Token.Issuer())
ensures gamma(rootKeyT) == unfolding acc(ValidToken(root), 3/4) in stringB(root.VerificationKey.KeyID(none[perm]))
ensures gamma(endorsedKeyT) == unfolding acc(ValidToken(root), 3/4) in stringB(root.Token.PureKeyID())
ensures iospec.P_Verifier(p0, ridT, s0) && place.token(p0) && s0 == s setminus 
	mset[fact.Fact] { 
		fact.St_Verifier_2(ridT), 
		fact.ValidTokenIn_Verifier(ridT, rootT) } union 
	mset[fact.Fact] { fact.St_Verifier_3(ridT, oiT, rootKeyT, endorsedKeyT) }
func ApplyIsOrganizationalEmblem(emblem, root *ADEMToken, p place.Place, s mset[fact.Fact], ridT, rootT term.Term) (p0 place.Place, s0 mset[fact.Fact], oiT, rootKeyT, endorsedKeyT term.Term) {

	// Parse root pattern
	ghost someRootKey, someOi, someEndorsedKey, someSig := RootEndPattern(root)

	// Apply pattern requirement for root patterns
	ghost rootKeyT, oiT, endorsedKeyT, sigT := RootEndorsementPatternRequirement(rootT, ridT, someRootKey, someOi, someEndorsedKey, someSig, s, p)

	// Apply IsOrganizationalEmblem rule
	unfold iospec.P_Verifier(p, ridT, s)
	unfold iospec.phiR_Verifier_6(p, ridT, s)
	l := mset[fact.Fact] { fact.St_Verifier_2(ridT), fact.ValidTokenIn_Verifier(ridT, rootT) }
	a := mset[claim.Claim] { }
	r := mset[fact.Fact] { fact.St_Verifier_3(ridT, oiT, rootKeyT, endorsedKeyT) }
	p = iospec.internBIO_e_IsOrganizationalEmblem(p, ridT, rootKeyT, oiT, endorsedKeyT, sigT, l, a, r)
	s = fact.U(l, r, s)

	return p, s, oiT, rootKeyT, endorsedKeyT
}

ghost
preserves acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
preserves acc(ValidToken(emblem), 3/4) && Emblem(emblem) && Abs(emblem) == gamma(embT)
preserves unfolding acc(ValidToken(emblem), 1/4) in
	unfolding acc(jwt.FieldMem(emblem.Token.Values()), 1/8) in
	emblem.Headers.ContentType() == string(consts.EmblemCty) && emblem.Token.Contains("ass") && emblem.Headers.Algorithm() != jwa.NoSignature && emblem.Token.Issuer() != "" && 
	gamma(oiT) == stringB(emblem.Token.Issuer()) && gamma(endorsedKeyT) == stringB(emblem.VerificationKey.KeyID(none[perm]))
requires iospec.P_Verifier(p, ridT, s) && place.token(p) && fact.St_Verifier_3(ridT, oiT, rootKeyT, endorsedKeyT) in s && fact.ValidTokenIn_Verifier(ridT, embT) in s
ensures iospec.P_Verifier(p0, ridT, s0) && place.token(p0) && s0 == s setminus 
	mset[fact.Fact] { 
		fact.St_Verifier_3(ridT, oiT, rootKeyT, endorsedKeyT), 
		fact.ValidTokenIn_Verifier(ridT, embT) } union 
	mset[fact.Fact]{ 
		fact.St_Verifier_4(ridT, oiT, rootKeyT),
		fact.OutFact_Verifier(ridT, SignedOut(aiT)),
		fact.OutFact_Verifier(ridT, OrganizationalOut(aiT, oiT)) }
func ApplyCollectAuthorityEndorsements(emblem *ADEMToken, p place.Place, s mset[fact.Fact], ridT, embT, rootKeyT, oiT, endorsedKeyT term.Term) (p0 place.Place, s0 mset[fact.Fact], aiT term.Term) {
	// Parse emblem pattern
	ghost someAi, someSig := SignedEmblemPattern(emblem, endorsedKeyT, oiT)

	// Apply pattern requirement for anon emblem patterns
	ghost aiT, sigT := SignedEmblemPatternRequirement(embT, ridT, rootKeyT, oiT, endorsedKeyT, someAi, someSig, s, p)

	// Apply CollectAuthorityEndorsements rule
	unfold iospec.P_Verifier(p, ridT, s)
	unfold iospec.phiR_Verifier_11(p, ridT, s)
	l := mset[fact.Fact] { fact.St_Verifier_3(ridT, oiT, rootKeyT, endorsedKeyT), fact.ValidTokenIn_Verifier(ridT, embT) }
	a := mset[claim.Claim] { claim.VerifiedEndorsed(ridT, oiT, aiT, endorsedKeyT), claim.VerifiedRootEndorsement(ridT, oiT, rootKeyT) }
	r := mset[fact.Fact] { fact.St_Verifier_4(ridT, oiT, rootKeyT),
	                       fact.OutFact_Verifier(ridT, SignedOut(aiT)),
	                       fact.OutFact_Verifier(ridT, OrganizationalOut(aiT, oiT)) }

	p = iospec.internBIO_e_CollectAuthorityEndorsements(p, ridT, oiT, rootKeyT, endorsedKeyT, aiT, sigT, l, a, r)
	s = fact.U(l, r, s)

	return p, s, aiT
}

ghost
preserves acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
preserves acc(ValidToken(endorsement), 3/4) && Endorsement(endorsement) && Abs(endorsement) == gamma(t)
preserves unfolding acc(ValidToken(endorsement), 1/4) in
	unfolding acc(jwt.FieldMem(endorsement.Token.Values()), 1/8) in
	endorsement.Headers.ContentType() == string(consts.EndorsementCty) && 
	endorsement.Token.Contains("key") && 
	endorsement.Token.Issuer() != "" && 
	endorsement.Token.Contains("log") && 
	endorsement.Token.Subject() != endorsement.Token.Issuer() && 
	gamma(oi) == stringB(endorsement.Token.Subject()) && 
	gamma(rootKey) == stringB(endorsement.Token.PureKeyID())
requires iospec.P_Verifier(p, rid, s) && place.token(p) && fact.St_Verifier_4(rid, oi, rootKey) in s && fact.ValidTokenIn_Verifier(rid, t) in s
ensures unfolding acc(ValidToken(endorsement), 1/2) in stringB(endorsement.Token.Issuer()) == gamma(auth)
ensures iospec.P_Verifier(p0, rid, s0) && place.token(p0) && s0 == s setminus 
	mset[fact.Fact] { 
		fact.ValidTokenIn_Verifier(rid, t) } union 
	mset[fact.Fact]{ 
		fact.OutFact_Verifier(rid, EndorsedOut(auth)) }
func ApplyIsEndorsedEmblem(endorsement *ADEMToken, p place.Place, s mset[fact.Fact], rid, oi, rootKey, t term.Term) (p0 place.Place, s0 mset[fact.Fact], auth term.Term) {
	// Parse authority endorsement pattern
	ghost someKey, someAuth, someSig := AuthEndPattern(endorsement, oi, rootKey)

	// Apply pattern requirement for root endorsement patterns
	ghost key, auth, sig := AuthorityEndorsementPatternRequirement(t, rid, someKey, someAuth, someSig, oi, rootKey, s, p)

	// Apply IsEndorsedEmblem rule
	unfold iospec.P_Verifier(p, rid, s)
	unfold iospec.phiR_Verifier_12(p, rid, s)
	l := mset[fact.Fact] { fact.St_Verifier_4(rid, oi, rootKey), fact.ValidTokenIn_Verifier(rid, t) }
	a := mset[claim.Claim] { claim.Neq(auth, oi), claim.VerifiedAuthorityEndorsement(rid, auth, key, oi, rootKey) }
	r := mset[fact.Fact] { fact.St_Verifier_4(rid, oi, rootKey), fact.OutFact_Verifier(rid, EndorsedOut(auth)) }

	p = iospec.internBIO_e_IsEndorsedEmblem(p, rid, oi, rootKey, key, auth, sig, l, a, r)
	s = fact.U(l, r, s)

	return p, s, auth
}
