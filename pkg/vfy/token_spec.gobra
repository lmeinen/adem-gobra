// +gobra
// ##(--onlyFilesWithHeader)
package vfy

import (
	"github.com/adem-wg/adem-proto/pkg/consts"
	"github.com/adem-wg/adem-proto/pkg/ident"
	"github.com/adem-wg/adem-proto/pkg/tokens"
	. "lib"
	"term"
	"pub"

	"github.com/lestrrat-go/jwx/v2/jwa"
	"github.com/lestrrat-go/jwx/v2/jwk"
	"github.com/lestrrat-go/jwx/v2/jwt"
)

// TODO: (lmeinen) Rewrite to separate mem permissions and field constraints

ghost
requires acc(ValidToken(t), _)
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _)
decreases _
pure func Emblem(t *ADEMToken) bool {
	return unfolding acc(ValidToken(t), _) in
	jwt.IsValid(t.Token) &&
		t.Token.Contains("ass") &&
		!t.Token.Contains("log") &&
		t.Headers.ContentType() == string(consts.EmblemCty) && 
		t.Headers.Algorithm() != jwa.NoSignature
}

ghost
requires acc(ValidToken(t), _)
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
pure func Endorsement(t *ADEMToken) bool {
	return unfolding acc(ValidToken(t), _) in
	jwt.IsValid(t.Token) &&
		t.Headers.ContentType() == string(consts.EndorsementCty) &&
		t.Token.Contains("end") &&
		typeOf(t.Token.Values()["end"]) == type[bool]
}

ghost
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
requires ValidToken(emblem)
requires TokenList(endorsements)
requires unfolding TokenList(endorsements) in forall i int :: { endorsements[i] } 0 <= i && i < len(endorsements) ==> unfolding TokenListElem(i, endorsements[i]) in Endorsement(endorsements[i])
pure func Root(root *ADEMToken, emblem *ADEMToken, endorsements []*ADEMToken, rootIdx int) bool {
	return 0 <= rootIdx && rootIdx < len(endorsements) &&
		unfolding TokenList(endorsements) in
		endorsements[rootIdx] == root &&
		unfolding TokenListElem(rootIdx, root) in
		(forall i int :: { endorsements[i] } 0 <= i && i < len(endorsements) && i != rootIdx ==> (
			unfolding TokenListElem(i, endorsements[i]) in
			endorsements[i].Endorses(root) ==> (
				unfolding ValidToken(endorsements[i]) in
				unfolding ValidToken(root) in
				root.Token.Issuer() != endorsements[i].Token.Issuer() || 
				!endorsements[i].Token.PureGet("end").(bool)))) &&
		unfolding ValidToken(root) in
		root.Token.Contains("key") &&
		root.Token.PureKeyID() != root.VerificationKey.KeyID(none[perm]) &&
		unfolding ValidToken(emblem) in
		(root.Token.Issuer() == emblem.Token.Issuer())
}

ghost
requires acc(ValidToken(endorser), 1/4)
requires acc(ValidToken(endorsed), 1/4)
decreases _
pure func (endorser *ADEMToken) Endorses(endorsed *ADEMToken) bool {
	return unfolding acc(ValidToken(endorser), 1/4) in
		endorser.Token.Contains("key") &&
		unfolding acc(ValidToken(endorsed), 1/4) in
		endorser.Token.Subject() == endorsed.Token.Issuer() && 
		endorser.Token.PureKeyID() == endorsed.VerificationKey.KeyID(none[perm])
}

pred ValidToken(t *ADEMToken) {
	acc(t) &&
	t.VerificationKey != nil &&
		acc(t.VerificationKey.Mem(), _) &&
	t.Headers != nil &&
	t.Token != nil && 
		acc(t.Token.Mem(), _) && 
		acc(jwt.FieldMem(t.Token.Values()), 1/2) &&
	unfolding acc(jwt.FieldMem(t.Token.Values()), 1/2) in
		t.Token.Contains("log") ==> t.Token.Issuer() != ""
}

// predicate wrapper to ensure injectivity of t
pred TokenListElem(_ int, t *ADEMToken) {
	t != nil && ValidToken(t)
}

pred TokenList(ts []*ADEMToken) {
	acc(ts) &&
	forall i int :: { TokenListElem(i, ts[i]) } 0 <= i && i < len(ts) ==> TokenListElem(i, ts[i])
}

ghost
requires acc(k.Mem(), _)
decreases _
pure func AbsKey(k jwk.Key) Bytes

// TODO: Is there any way to get the signature in here? Do we even need it?
// 	--> Add 'exists' signature term to channel invariant: we don't need more info than that

ghost
requires acc(ValidToken(t), _)
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
pure func Abs(t *ADEMToken) Bytes

ghost
requires acc(ValidToken(t), 1/2)
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
requires unfolding acc(ValidToken(t), 1/4) in
	unfolding acc(jwt.FieldMem(t.Token.Values()), 1/8) in
	t.Headers.ContentType() == string(consts.EmblemCty) && t.Token.Contains("ass") && t.Headers.Algorithm() == jwa.NoSignature
ensures acc(ValidToken(t), 1/2)
ensures acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
ensures unfolding acc(ValidToken(t), 1/4) in
	unfolding acc(jwt.FieldMem(t.Token.Values()), 1/8) in
	t.Headers.ContentType() == string(consts.EmblemCty) && t.Token.Contains("ass") && t.Headers.Algorithm() == jwa.NoSignature &&
	Abs(t) == tuple2B(emblemB(), stringB(t.Token.PureAI())) &&
	oneTerm(stringB(t.Token.PureAI())) == ai &&
	Abs(t) == gamma(term.pair(term.pubTerm(pub.const_emblem_pub()), ai))
func UnsignedEmblemPattern(t *ADEMToken) (ai term.Term)

ghost
requires acc(ValidToken(t), 1/2)
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
requires unfolding acc(ValidToken(t), 1/4) in
	unfolding acc(jwt.FieldMem(t.Token.Values()), 1/8) in
	t.Headers.ContentType() == string(consts.EmblemCty) && t.Token.Contains("ass") && t.Headers.Algorithm() != jwa.NoSignature && t.Token.Issuer() == ""
ensures acc(ValidToken(t), 1/2)
ensures acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
ensures unfolding acc(ValidToken(t), 1/4) in
	unfolding acc(jwt.FieldMem(t.Token.Values()), 1/8) in
	t.Headers.ContentType() == string(consts.EmblemCty) && t.Token.Contains("ass") && t.Headers.Algorithm() != jwa.NoSignature && t.Token.Issuer() == "" &&
	Abs(t) == tuple3B(stringB(t.VerificationKey.KeyID(none[perm])), tuple2B(emblemB(), stringB(t.Token.PureAI())), stringB("sig")) &&
	oneTerm(stringB(t.VerificationKey.KeyID(none[perm]))) == key &&
	oneTerm(stringB(t.Token.PureAI())) == ai &&
	oneTerm(stringB("sig")) == sig &&
	Abs(t) == gamma(tuple3(key, term.pair(term.pubTerm(pub.const_emblem_pub()), ai), sig))
func AnonEmblemPattern(t *ADEMToken) (key, ai, sig term.Term)

ghost
requires acc(ValidToken(t), 1/2)
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
requires unfolding acc(ValidToken(t), 1/4) in
	unfolding acc(jwt.FieldMem(t.Token.Values()), 1/8) in
	t.Headers.ContentType() == string(consts.EmblemCty) && t.Token.Contains("ass") && t.Headers.Algorithm() != jwa.NoSignature && t.Token.Issuer() != "" && gamma(oi) == stringB(t.Token.Issuer()) && gamma(key) == stringB(t.VerificationKey.KeyID(none[perm]))
ensures acc(ValidToken(t), 1/2)
ensures acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
ensures unfolding acc(ValidToken(t), 1/4) in
	unfolding acc(jwt.FieldMem(t.Token.Values()), 1/8) in
	t.Headers.ContentType() == string(consts.EmblemCty) && t.Token.Contains("ass") && t.Headers.Algorithm() != jwa.NoSignature && t.Token.Issuer() != "" && gamma(oi) == stringB(t.Token.Issuer()) && gamma(key) == stringB(t.VerificationKey.KeyID(none[perm])) &&
	Abs(t) == tuple4B(stringB(t.VerificationKey.KeyID(none[perm])), stringB(t.Token.Issuer()), tuple3B(emblemB(), stringB(t.Token.PureAI()), stringB(t.Token.Issuer())), stringB("sig")) &&
	oneTerm(stringB(t.Token.PureAI())) == ai &&
	oneTerm(stringB("sig")) == sig &&
	Abs(t) == gamma(tuple4(key, oi, tuple3(term.pubTerm(pub.const_emblem_pub()), ai, oi), sig))
func SignedEmblemPattern(t *ADEMToken, key, oi term.Term) (ai, sig term.Term)

ghost
requires acc(ValidToken(t), 1/2)
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
requires unfolding acc(ValidToken(t), 1/4) in
	unfolding acc(jwt.FieldMem(t.Token.Values()), 1/8) in
	t.Headers.ContentType() == string(consts.EndorsementCty) && t.Token.Contains("key") && t.Token.Issuer() != "" && !t.Token.Contains("log") && gamma(oi) == stringB(t.Token.Issuer()) && t.Token.Issuer() == t.Token.Subject() && gamma(endorsedKey) == stringB(t.VerificationKey.KeyID(none[perm]))
ensures acc(ValidToken(t), 1/2)
ensures acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
ensures unfolding acc(ValidToken(t), 1/4) in
	unfolding acc(jwt.FieldMem(t.Token.Values()), 1/8) in
	t.Headers.ContentType() == string(consts.EndorsementCty) && t.Token.Contains("key") && t.Token.Issuer() != "" && !t.Token.Contains("log") && gamma(oi) == stringB(t.Token.Issuer()) && gamma(oi) == stringB(t.Token.Subject()) && gamma(endorsedKey) == stringB(t.Token.PureKeyID()) &&
	Abs(t) == tuple4B(stringB(t.VerificationKey.KeyID(none[perm])), stringB(t.Token.Issuer()), tuple3B(endorsementB(), stringB(t.Token.Issuer()), stringB(t.Token.PureKeyID())), stringB("sig")) &&
	oneTerm(stringB(t.Token.PureKeyID())) == newkey &&
	oneTerm(stringB("sig")) == sig &&
	Abs(t) == gamma(tuple4(endorsedKey, oi, tuple3(term.pubTerm(pub.const_end_pub()), oi, newkey), sig))
func OrgEndPattern(t *ADEMToken, oi, endorsedKey term.Term) (newkey, sig term.Term)

// TODO: (lmeinen) Use oneTerm to get explicit witness

ghost
requires acc(ValidToken(t), 1/2)
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
requires unfolding acc(ValidToken(t), 1/4) in
	unfolding acc(jwt.FieldMem(t.Token.Values()), 1/8) in
	t.Headers.ContentType() == string(consts.EndorsementCty) && t.Token.Contains("key") && t.Token.Issuer() != "" && t.Token.Contains("log") && t.Token.Subject() == t.Token.Issuer()
ensures acc(ValidToken(t), 1/2)
ensures acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
ensures unfolding acc(ValidToken(t), 1/4) in
	unfolding acc(jwt.FieldMem(t.Token.Values()), 1/8) in
	t.Headers.ContentType() == string(consts.EndorsementCty) && t.Token.Contains("key") && t.Token.Issuer() != "" && t.Token.Contains("log") && gamma(oi) == stringB(t.Token.Subject()) && gamma(endorsedkey) == stringB(t.Token.PureKeyID()) &&
	Abs(t) == tuple4B(stringB(t.VerificationKey.KeyID(none[perm])), stringB(t.Token.Issuer()), tuple3B(rootEndB(), stringB(t.Token.Subject()), stringB(t.Token.PureKeyID())), stringB("sig")) &&
	oneTerm(stringB(t.VerificationKey.KeyID(none[perm]))) == rootkey &&
	oneTerm(stringB(t.Token.Issuer())) == oi &&
	oneTerm(stringB(t.Token.PureKeyID())) == endorsedkey &&
	oneTerm(stringB("sig")) == sig &&
	Abs(t) == gamma(tuple4(rootkey, oi, tuple3(term.pubTerm(pub.const_root_end_pub()), oi, endorsedkey), sig))
func RootEndPattern(t *ADEMToken) (rootkey, oi, endorsedkey, sig term.Term)

ghost
requires acc(ValidToken(t), 1/2)
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
requires unfolding acc(ValidToken(t), 1/4) in
	unfolding acc(jwt.FieldMem(t.Token.Values()), 1/8) in
	t.Headers.ContentType() == string(consts.EndorsementCty) && t.Token.Contains("key") && t.Token.Issuer() != "" && t.Token.Contains("log") && t.Token.Subject() != t.Token.Issuer() && gamma(oi) == stringB(t.Token.Subject()) && gamma(endorsedKey) == stringB(t.Token.PureKeyID())
ensures acc(ValidToken(t), 1/2)
ensures acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
ensures unfolding acc(ValidToken(t), 1/4) in
	unfolding acc(jwt.FieldMem(t.Token.Values()), 1/8) in
	t.Headers.ContentType() == string(consts.EndorsementCty) && t.Token.Contains("key") && t.Token.Issuer() != "" && t.Token.Contains("log") && gamma(oi) == stringB(t.Token.Subject()) && gamma(endorsedKey) == stringB(t.Token.PureKeyID()) &&
	Abs(t) == tuple4B(stringB(t.VerificationKey.KeyID(none[perm])), stringB(t.Token.Issuer()), tuple3B(rootEndB(), stringB(t.Token.Subject()), stringB(t.Token.PureKeyID())), stringB("sig")) &&
	oneTerm(stringB(t.VerificationKey.KeyID(none[perm]))) == key &&
	oneTerm(stringB(t.Token.Issuer())) == auth &&
	oneTerm(stringB("sig")) == sig &&
	Abs(t) == gamma(tuple4(key, auth, tuple3(term.pubTerm(pub.const_root_end_pub()), oi, endorsedKey), sig))
func AuthEndPattern(t *ADEMToken, oi, endorsedKey term.Term) (key, auth, sig term.Term)

ghost
trusted
requires acc(ValidToken(t), _)
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
pure func BackupAbs(t *ADEMToken) Bytes {
	// (1) note the PureGet call, it is a consequence of Gobra's limitation that a pure function cannot have multiple return values - as a consequence AbsAI can't require any permissions, either
	return unfolding acc(ValidToken(t), _) in
		unfolding acc(jwt.FieldMem(t.Token.Values()), _) in
        let oi := t.Token.Issuer() in
		let key := AbsKey(t.VerificationKey) in
		let sig := stringB("sig") in 
		t.Headers.ContentType() == string(consts.EmblemCty) && t.Token.Contains("ass") ?
			let ai := t.Token.PureGet("ass").([]*ident.AI) in
			let aiB := (unfolding acc(tokens.AssMem(ai), _) in ident.AbsAI(ai)) in
			// emblem
			(t.Headers.Algorithm() == jwa.NoSignature ?
				// unsigned
				tuple2B(emblemB(), aiB) :
				// signed
                oi == "" ?
                    // anonymous
                    tuple3B(key, tuple2B(emblemB(), aiB), sig) :
                    // organizational
                    tuple4B(key, stringB(oi), tuple3B(emblemB(), aiB, stringB(oi)), sig)) :
			// endorsement
			(t.Headers.ContentType() == string(consts.EndorsementCty) && t.Token.Contains("key") ?
        		let sub := t.Token.Subject() in
        		let endKey := t.Token.PureGet("key").(tokens.EmbeddedKey) in
				let endKeyB := (unfolding acc(tokens.KeyMem(endKey), _) in AbsKey(endKey.Key)) in
        		(oi == "" ?
        		    // anonymous
        		    tuple3B(key, tuple2B(endorsementB(), endKeyB), sig) :
        		    (t.Token.Contains("log") ?
        		        // root
        		        tuple4B(key, stringB(oi), tuple3B(rootEndB(), stringB(sub), endKeyB), sig) :
        		        // internal
        		        tuple4B(key, stringB(oi), tuple3B(endorsementB(), stringB(oi), endKeyB), sig))) :
				GenericBytes(t))
}

ghost
pure func GenericBytes(t *ADEMToken) Bytes