// +gobra
// ##(--onlyFilesWithHeader)
package vfy

import (
	"github.com/adem-wg/adem-proto/pkg/consts"
	"github.com/adem-wg/adem-proto/pkg/ident"
	"github.com/adem-wg/adem-proto/pkg/tokens"
	. "github.com/adem-wg/adem-proto/pkg/goblib"

	"github.com/lestrrat-go/jwx/v2/jwa"
	"github.com/lestrrat-go/jwx/v2/jwt"
)

pred ValidToken(t *ADEMToken) {
	acc(t) &&
	t.VerificationKey != nil &&
		acc(t.VerificationKey.Mem(), _) &&
	t.Headers != nil &&
	t.Token != nil && 
		acc(t.Token.Mem(), _)
}

pred Endorsement(t *ADEMToken) {
	acc(ValidToken(t), 1/2) &&
	acc(t, 1/2) &&
	t.Token != nil &&
		jwt.IsValid(t.Token) &&
		acc(&jwt.Custom, _) && acc(jwt.Custom, _) &&
		unfolding acc(ValidToken(t), 1/2) in 
			t.Token.Contains("end") &&
			typeOf(t.Token.Values()["end"]) == type[bool]
}

pred Emblem(t *ADEMToken) {
	acc(ValidToken(t), 1/2) &&
	acc(t, 1/2) &&
	t.Token != nil &&
		jwt.IsValid(t.Token) &&
		acc(&jwt.Custom, _) && acc(jwt.Custom, _) &&
		unfolding acc(ValidToken(t), 1/2) in t.Token.Contains("ass")
}

// predicate wrapper to ensure injectivity of t
pred TokenListElem(_ int, t *ADEMToken) {
	t != nil && ValidToken(t)
}

pred EndListElem(_ int, t *ADEMToken) {
	t != nil && Endorsement(t)
}

pred TokenList(ts []*ADEMToken) {
	acc(ts) &&
	forall i int :: { ts[i] } 0 <= i && i < len(ts) ==> TokenListElem(i, ts[i])
}

pred EndorsementList(ts []*ADEMToken) {
	acc(ts) &&
	forall i int :: { ts[i] } 0 <= i && i < len(ts) ==> EndListElem(i, ts[i])
}

ghost
trusted
requires acc(rawToken, _)
decreases _
pure func AbsBytes(rawToken []byte) (res Bytes)

// TODO: Is there any way to get the signature in here? Do we even need it?
// TODO: Ensure that all proper constraints are collected by the end of organizastional/endorsed verification calls

ghost
requires acc(ValidToken(t), _)
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
requires unfolding acc(ValidToken(t), _) in (
	t.Headers.ContentType() == string(consts.EmblemCty) ? t.Token.Contains("ass") : t.Token.Contains("key"))
pure func Abs(t *ADEMToken) Bytes {
	// (1) note the PureGet call, it is a consequence of Gobra's limitation that a pure function cannot have multiple return values - as a consequence AbsAI can't require any permissions, either
	return unfolding acc(ValidToken(t), _) in
        let oi := t.Token.Issuer() in
        let sub := t.Token.Subject() in
		let key := keyB(t.VerificationKey) in
		let sig := stringB("sig") in 
		t.Headers.ContentType() == string(consts.EmblemCty) ?
			let ai := ident.AbsAI(t.Token.Values()["ass"].([]*ident.AI)) in
			// let ai := stringB("ai") in
			// emblem
			(t.Headers.Algorithm() == jwa.NoSignature ?
				// unsigned
				tuple2B(emblemB(), ai) :
				// signed
                oi == "" ?
                    // anonymous
                    tuple3B(key, tuple2B(emblemB(), ai), sig) :
                    // organizational
                    tuple4B(key, stringB(oi), tuple3B(emblemB(), ai, stringB(oi)), sig)) :
			// endorsement
        	let endKey := keyB(t.Token.Values()["key"].(tokens.EmbeddedKey).Key) in
			// let endKey := stringB("key") in
            (oi == "" ?
                // anonymous
                tuple3B(key, tuple2B(endorsementB(), endKey), sig) :
                (t.Token.Contains("log") ?
                    // root
                    tuple4B(key, stringB(oi), tuple3B(rootEndB(), stringB(sub), endKey), sig) :
                    // internal
                    tuple4B(key, stringB(oi), tuple3B(endorsementB(), stringB(oi), endKey), sig)))
}

ghost
requires acc(ValidToken(t), _)
requires unfolding acc(ValidToken(t), _) in 
	t.Headers.ContentType() == string(consts.EmblemCty) && 
	t.Token.Contains("ass") &&
	t.Headers.Algorithm() == jwa.NoSignature
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
func unsignedEmblem(t *ADEMToken) {
	b := Abs(t)
	assert exists b1, b2 Bytes :: b == tuple2B(b1,b2)
}

ghost
requires acc(ValidToken(t), _)
requires unfolding acc(ValidToken(t), _) in 
	t.Headers.ContentType() == string(consts.EmblemCty) && 
	t.Token.Contains("ass") &&
	t.Headers.Algorithm() == jwa.ES256 &&
	t.Token.Issuer() == ""
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
func signedEmblem(t *ADEMToken) {
	b := Abs(t)
	assert exists b1, b2, b3 Bytes :: b == tuple3B(b1, b2, b3)
}

ghost
requires acc(ValidToken(t), _)
requires unfolding acc(ValidToken(t), _) in 
	t.Headers.ContentType() == string(consts.EmblemCty) && 
	t.Token.Contains("ass") &&
	t.Headers.Algorithm() == jwa.ES256 &&
	t.Token.Issuer() == "https://emblem.flinker.com"
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
func organizationalEmblem(t *ADEMToken) {
	b := Abs(t)
	assert false
	assert exists b1, b2, b3, b4 Bytes :: b == tuple4B(b1, b2, b3, b4)
}

ghost
requires acc(ValidToken(t), _)
requires unfolding acc(ValidToken(t), _) in 
	t.Headers.ContentType() == string(consts.EndorsementCty) && 
	t.Token.Contains("key") &&
	t.Token.Contains("log") &&
	t.Token.Issuer() == "https://emblem.flinker.com" &&
	t.Token.Subject() == "https://emblem.flinker.com"
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
func rootEndorsement(t *ADEMToken) {
	b := Abs(t)
	assert false // TODO: Fix
	assert exists b1, b2, b3, b4 Bytes :: b == tuple4B(b1, b2, b3, b4)
}

ghost
requires acc(ValidToken(t1), _) && acc(ValidToken(t2), _)
requires unfolding acc(ValidToken(t1), _) in t1.Token.Contains("ass") && t1.Headers.ContentType() == string(consts.EmblemCty) && t1.Headers.Algorithm() != jwa.NoSignature && t1.Token.Issuer() != ""
requires unfolding acc(ValidToken(t2), _) in t2.Token.Contains("ass") && t2.Headers.ContentType() == string(consts.EmblemCty) && t2.Headers.Algorithm() != jwa.NoSignature && t2.Token.Issuer() != ""
requires unfolding acc(ValidToken(t1), _) in unfolding acc(ValidToken(t2), _) in t1.Token.Issuer() != t2.Token.Issuer()
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
func foo(t1 *ADEMToken, t2 *ADEMToken) {
	b := Abs(t1)
	bb := Abs(t2)
	assert exists b1,b2,b3,b4 Bytes :: b == tuple4B(b1,b2,b3,b4)
	assert exists b1,b2,b3,b4 Bytes :: bb == tuple4B(b1,b2,b3,b4)
	assert b == Abs(t1)
	assert bb == Abs(t2)
	// TODO: Do we need injectivity of the Bytes domain?
	// assert b != bb
}

/*
func termConstraints(t *ADEMToken, endorsedBy map[string]*ADEMToken) {
	if t.Headers.ContentType() == string(consts.EmblemCty) {
		// is emblem
		E, ok := t.Token.Get("ass")
		//  assert ok
		if t.Headers.Algorithm() == jwa.NoSignature {
			// is unsigned emblem
			//  assert Abs(t) == <'emblem', E>
		} else if oi := t.Token.Issuer(); oi == "" {
			// is anon emblem
			//  assert Abs(t) == <t.VerificationKey.KeyID(), <'emblem', E>, term.sign(t.Token, term.pk(???))>
		} else {
			// is organizational emblem
			//  assert Abs(t) == <t.VerificationKey.KeyID(), oi, <'emblem', E, oi>, term.sign(t.Token, term.pk(???))>
		}
	} else {
		// is endorsement
		endKey, ok := t.Token.Get("end")
		//  assert ok
		if oi := t.Token.Issuer(); oi == "" {
			// is anon endorsement
			// assert Abs(t) == <t.VerificationKey.KeyID(), <'end', endKey>,  term.sign(t.Token, term.pk(???))>
		} else if end := endorsedBy[t.VerificationKey.KeyID()]; end == nil || end.Token.Issuer() != oi {
			// is root endorsement
			//  assert Abs(t) == <t.VerificationKey.KeyID(), oi, <'root_end', t.Token.Subject(), endKey>,  term.sign(t.Token, term.pk(???))>
		} else {
			// is internal endorsement
			//  assert oi == t.Token.Subject()
			//  assert Abs(t) == <t.VerificationKey.KeyID(), oi, <'end', oi, endKey>,  term.sign(t.Token, term.pk(???))>

		}

	}
}
*/
