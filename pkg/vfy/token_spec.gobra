// +gobra
// ##(--onlyFilesWithHeader)
package vfy

import (
	"github.com/adem-wg/adem-proto/pkg/consts"
	"github.com/adem-wg/adem-proto/pkg/ident"
	"github.com/adem-wg/adem-proto/pkg/tokens"
	. "lib"

	"github.com/lestrrat-go/jwx/v2/jwa"
	"github.com/lestrrat-go/jwx/v2/jwk"
	"github.com/lestrrat-go/jwx/v2/jwt"
)

pred ValidToken(t *ADEMToken) {
	acc(t) &&
	t.VerificationKey != nil &&
		acc(t.VerificationKey.Mem(), _) &&
	t.Headers != nil &&
	t.Token != nil && 
		t.Token.Mem() && 
		jwt.FieldMem(t.Token.Values())
}

pred Endorsement(t *ADEMToken) {
	acc(ValidToken(t), _) &&
	acc(t, _) &&
	t.Token != nil &&
		jwt.IsValid(t.Token) &&
		acc(&jwt.Custom, _) && acc(jwt.Custom, _) &&
		unfolding acc(ValidToken(t), _) in 
			t.Token.Contains("end") &&
			typeOf(t.Token.Values()["end"]) == type[bool]
}

pred Emblem(t *ADEMToken) {
	acc(ValidToken(t), _) &&
	acc(t, _) &&
	t.Token != nil &&
		jwt.IsValid(t.Token) &&
		acc(&jwt.Custom, _) && acc(jwt.Custom, _) &&
		(unfolding acc(ValidToken(t), _) in 
			t.Token.Contains("ass") &&
			t.Headers.ContentType() == string(consts.EmblemCty) && 
			t.Headers.Algorithm() != jwa.NoSignature)
}

// predicate wrapper to ensure injectivity of t
pred TokenListElem(_ int, t *ADEMToken) {
	t != nil && acc(ValidToken(t), _)
}

pred EndListElem(_ int, t *ADEMToken) {
	t != nil && Endorsement(t)
}

pred TokenList(ts []*ADEMToken) {
	acc(ts) &&
	forall i int :: { ts[i] } 0 <= i && i < len(ts) ==> TokenListElem(i, ts[i])
}

pred EndorsementList(ts []*ADEMToken) {
	acc(ts) &&
	forall i int :: { ts[i] } 0 <= i && i < len(ts) ==> EndListElem(i, ts[i])
}

ghost
requires acc(k.Mem(), _)
decreases _
pure func AbsKey(k jwk.Key) Bytes

// TODO: Is there any way to get the signature in here? Do we even need it?
// 	--> Add signature term to channel invariant
// TODO: Ensure that all proper constraints are collected by the end of organizastional/endorsed verification calls

ghost
requires acc(ValidToken(t), _)
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
pure func Abs(t *ADEMToken) Bytes {
	// (1) note the PureGet call, it is a consequence of Gobra's limitation that a pure function cannot have multiple return values - as a consequence AbsAI can't require any permissions, either
	return unfolding acc(ValidToken(t), _) in
		unfolding acc(jwt.FieldMem(t.Token.Values()), _) in
        let oi := t.Token.Issuer() in
		let key := AbsKey(t.VerificationKey) in
		let sig := stringB("sig") in 
		t.Headers.ContentType() == string(consts.EmblemCty) && t.Token.Contains("ass") ?
			let ai := t.Token.PureGet("ass").([]*ident.AI) in
			let aiB := (unfolding acc(tokens.AssMem(ai), _) in ident.AbsAI(ai)) in
			// emblem
			(t.Headers.Algorithm() == jwa.NoSignature ?
				// unsigned
				tuple2B(emblemB(), aiB) :
				// signed
                oi == "" ?
                    // anonymous
                    tuple3B(key, tuple2B(emblemB(), aiB), sig) :
                    // organizational
                    tuple4B(key, stringB(oi), tuple3B(emblemB(), aiB, stringB(oi)), sig)) :
			// endorsement
			(t.Headers.ContentType() == string(consts.EndorsementCty) && t.Token.Contains("key") ?
        		let sub := t.Token.Subject() in
        		let endKey := t.Token.PureGet("key").(tokens.EmbeddedKey) in
				let endKeyB := (unfolding acc(tokens.KeyMem(endKey), _) in AbsKey(endKey.Key)) in
        		(oi == "" ?
        		    // anonymous
        		    tuple3B(key, tuple2B(endorsementB(), endKeyB), sig) :
        		    (t.Token.Contains("log") ?
        		        // root
        		        tuple4B(key, stringB(oi), tuple3B(rootEndB(), stringB(sub), endKeyB), sig) :
        		        // internal
        		        tuple4B(key, stringB(oi), tuple3B(endorsementB(), stringB(oi), endKeyB), sig))) :
				GenericBytes(t))
}

ghost
pure func GenericBytes(t *ADEMToken) Bytes

ghost
requires acc(ValidToken(t), _)
requires unfolding acc(ValidToken(t), _) in 
	t.Headers.ContentType() == string(consts.EmblemCty) && 
	t.Token.Contains("ass") &&
	t.Headers.Algorithm() == jwa.NoSignature
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
func unsignedEmblem(t *ADEMToken) {
	b := Abs(t)
	assert exists b1, b2 Bytes :: b == tuple2B(b1,b2)
}

ghost
requires acc(ValidToken(t), _)
requires unfolding acc(ValidToken(t), _) in 
	t.Headers.ContentType() == string(consts.EmblemCty) && 
	t.Token.Contains("ass") &&
	t.Headers.Algorithm() == jwa.ES256 &&
	t.Token.Issuer() == ""
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
func signedEmblem(t *ADEMToken) {
	b := Abs(t)
	assert exists b1, b2, b3 Bytes :: b == tuple3B(b1, b2, b3)
}

ghost
requires acc(ValidToken(t), _)
requires unfolding acc(ValidToken(t), _) in 
	t.Headers.ContentType() == string(consts.EmblemCty) && 
	t.Token.Contains("ass") &&
	t.Headers.Algorithm() == jwa.ES256 &&
	t.Token.Issuer() == "https://emblem.flinker.com"
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
func organizationalEmblem(t *ADEMToken) {
	b := Abs(t)
	assert exists b1, b2, b3, b4 Bytes :: b == tuple4B(b1, b2, b3, b4)
}

ghost
requires acc(ValidToken(t), _)
requires unfolding acc(ValidToken(t), _) in 
	t.Headers.ContentType() == string(consts.EndorsementCty) && 
	t.Token.Contains("key") &&
	t.Token.Contains("log") &&
	t.Token.Issuer() == "https://emblem.flinker.com" &&
	t.Token.Subject() == "https://emblem.flinker.com"
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
func rootEndorsement(t *ADEMToken) {
	b := Abs(t)
	assert exists b1, b2, b3, b4 Bytes :: b == tuple4B(b1, b2, b3, b4)
}

ghost
requires acc(ValidToken(t1), _) && acc(ValidToken(t2), _)
requires unfolding acc(ValidToken(t1), _) in t1.Token.Contains("ass") && t1.Headers.ContentType() == string(consts.EmblemCty) && t1.Headers.Algorithm() != jwa.NoSignature && t1.Token.Issuer() != ""
requires unfolding acc(ValidToken(t2), _) in t2.Token.Contains("ass") && t2.Headers.ContentType() == string(consts.EmblemCty) && t2.Headers.Algorithm() != jwa.NoSignature && t2.Token.Issuer() != ""
requires unfolding acc(ValidToken(t1), _) in unfolding acc(ValidToken(t2), _) in t1.Token.Issuer() != t2.Token.Issuer()
requires acc(&jwt.Custom, _) && acc(jwt.Custom, _) && tokens.CustomFields(jwt.Custom)
func blub(t1 *ADEMToken, t2 *ADEMToken) {
	b := Abs(t1)
	bb := Abs(t2)
	assert exists b1,b2,b3,b4 Bytes :: b == tuple4B(b1,b2,b3,b4)
	assert exists b1,b2,b3,b4 Bytes :: bb == tuple4B(b1,b2,b3,b4)
	assert b == Abs(t1)
	assert bb == Abs(t2)
	// TODO: Do we need injectivity of the Bytes domain?
	// assert b != bb
}
