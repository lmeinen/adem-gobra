// +gobra
// ##(--onlyFilesWithHeader)
package util

type Fact domain {
    func ValidTokenIn_Verifier(int, int) Fact
    func OutFact_Verifier(int, int) Fact

    func getType(Fact) int
    func getFirst(Fact) int
    func getSecond(Fact) int

    axiom {
        forall p1, p2 int :: { ValidTokenIn_Verifier(p1, p2) } getType(ValidTokenIn_Verifier(p1, p2)) == 0 &&
            getFirst(ValidTokenIn_Verifier(p1, p2)) == p1 &&
            getSecond(ValidTokenIn_Verifier(p1, p2)) == p2
    }

    axiom {
        forall p1, p2 int :: { OutFact_Verifier(p1, p2) } getType(OutFact_Verifier(p1, p2)) == 1 &&
            getFirst(OutFact_Verifier(p1, p2)) == p1 &&
            getSecond(OutFact_Verifier(p1, p2)) == p2
    }
}

ghost
pure func EndorsedOut(authT int) int

ghost
requires 0 < len(endTs)
requires 0 <= i0 && i0 < len(endTs)
requires forall i int :: { endTs[i] } 0 <= i && i0 <= i && i < len(endTs) ==> endTs[i] # endTs[i0:] <= ValidTokenIn_Verifier(ridT, endTs[i]) # s0
func foo(endTs seq[int], ridT int, s0 mset[Fact], i0 int, authT int) {
    eT := endTs[i0]
    s1 := ((s0 setminus mset[Fact] { ValidTokenIn_Verifier(ridT, eT) }) union mset[Fact] { OutFact_Verifier(ridT, EndorsedOut(authT)) })

    // Passes
    assert forall i int :: { endTs[i] } 0 <= i && i0 <= i && i < len(endTs) ==> endTs[i] # endTs[i0:] <= ValidTokenIn_Verifier(ridT, endTs[i]) # s0

    // Passes
    assert s1 == ((s0 setminus mset[Fact] { ValidTokenIn_Verifier(ridT, eT) }) union mset[Fact] { OutFact_Verifier(ridT, EndorsedOut(authT)) })
    /*
    s0Temp := s0 setminus mset[Fact] { ValidTokenIn_Verifier(ridT, eT) }
    s0Count := ValidTokenIn_Verifier(ridT, endTs[i0]) # s0
    s0TempCount := ValidTokenIn_Verifier(ridT, endTs[i0]) # s0Temp
    s1Count := ValidTokenIn_Verifier(ridT, endTs[i0]) # s1
    if s0Count >= 1 {
        assert s0TempCount < s0Count

        outmset := mset[Fact] { OutFact_Verifier(ridT, EndorsedOut(authT)) }
        assert s1 == s0Temp union outmset
        assert OutFact_Verifier(ridT, EndorsedOut(authT)) in outmset
        assert len(outmset) == 1
        assert OutFact_Verifier(ridT, EndorsedOut(authT)) != ValidTokenIn_Verifier(ridT, endTs[i0])
        assert !(ValidTokenIn_Verifier(ridT, endTs[i0]) in outmset)
        assert ValidTokenIn_Verifier(ridT, endTs[i0]) # outmset == 0

        assert s0TempCount == s1Count
        assert s1Count < s0Count
    } else {
        assert s1Count == s0Count
    }
    */
    // Passes
    assert eT == endTs[i0]

    // forall introduction
    arbI := getArbInt()
    if 0 <= arbI && i0 <= arbI && arbI < len(endTs) {
        assert endTs[arbI] # endTs[i0:] <= ValidTokenIn_Verifier(ridT, endTs[arbI]) # s0

        if ValidTokenIn_Verifier(ridT, endTs[arbI]) in s0 && arbI == i0 {
            // assert (ValidTokenIn_Verifier(ridT, endTs[arbI]) # s1) == (ValidTokenIn_Verifier(ridT, endTs[arbI]) # s0) - 1
        } else if !(ValidTokenIn_Verifier(ridT, endTs[arbI]) in s0) {
            // assert (ValidTokenIn_Verifier(ridT, endTs[arbI]) # s1) == (ValidTokenIn_Verifier(ridT, endTs[arbI]) # s0)
            // assert ValidTokenIn_Verifier(ridT, endTs[arbI]) # s0 == 0
            // assert ValidTokenIn_Verifier(ridT, endTs[arbI]) # s1 == 0
            // assert endTs[arbI] # endTs[i0:] == 0
            // the following assertion is necessary!
            assert !(endTs[arbI] in endTs[i0:])
            // assert !(endTs[arbI] in endTs[i0+1:])
            // assert set(endTs[i0+1:]) subset set(endTs[i0:])
            // assert mset(endTs[i0+1:]) subset mset(endTs[i0:])
            // assert endTs[arbI] # endTs[i0+1:] == 0
            // we can now derive a contradiction:
            assert false
        } else {
            // assert ValidTokenIn_Verifier(ridT, endTs[arbI]) in s0
            // assert i0 < arbI
            if endTs[arbI] == endTs[i0] {
                // assert (ValidTokenIn_Verifier(ridT, endTs[arbI]) # s1) == (ValidTokenIn_Verifier(ridT, endTs[arbI]) # s0) - 1
                // assert endTs[arbI] in endTs[i0:]
                // the following assertion is necessary!
                assert endTs[i0:] == seq[int]{ endTs[arbI] } ++ endTs[i0+1:]
                // assert endTs[arbI] # seq[int]{ endTs[arbI] } == 1
                // assert endTs[arbI] # (seq[int]{ endTs[arbI] } ++ endTs[i0+1:]) == (endTs[arbI] # seq[int]{ endTs[arbI] }) + (endTs[arbI] # endTs[i0+1:])
                // assert endTs[arbI] # (seq[int]{ endTs[arbI] } ++ endTs[i0+1:]) == 1 + (endTs[arbI] # endTs[i0+1:])
                // assert (endTs[arbI] # endTs[i0:]) == endTs[arbI] # (seq[int]{ endTs[arbI] } ++ endTs[i0+1:])

                // assert endTs[i0:] == seq[int]{ endTs[arbI] } ++ endTs[i0+1:]
                // assert (endTs[arbI] # endTs[i0:]) == (endTs[arbI] # (seq[int]{ endTs[arbI] } ++ endTs[i0+1:]))
                // assert (endTs[arbI] # endTs[i0:]) == 1 + (endTs[arbI] # endTs[i0+1:])
            } else {
                // assert (ValidTokenIn_Verifier(ridT, endTs[arbI]) # s1) == (ValidTokenIn_Verifier(ridT, endTs[arbI]) # s0)
                // the following assertion is necessary!
                assert endTs[i0:] == seq[int]{ endTs[i0] } ++ endTs[i0+1:]
            }
        }

        if i0 < arbI {
            assert endTs[arbI] # endTs[i0+1:] <= ValidTokenIn_Verifier(ridT, endTs[arbI]) # s1
        }
    }
    // show that it holds for an arbitrary i and then assume it:
    assert 0 <= arbI && i0 < arbI && arbI < len(endTs) ==> endTs[arbI] # endTs[i0+1:] <= ValidTokenIn_Verifier(ridT, endTs[arbI]) # s1
    assume forall i int :: { endTs[i] } 0 <= i && i0 < i && i < len(endTs) ==> endTs[i] # endTs[i0+1:] <= ValidTokenIn_Verifier(ridT, endTs[i]) # s1


    // Fails
    // assert forall i int :: { endTs[i] } 0 <= i && i0 < i && i < len(endTs) ==> endTs[i] # endTs[i:] <= ValidTokenIn_Verifier(ridT, endTs[i]) # s1
}

func getArbInt() int