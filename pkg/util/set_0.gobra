package util

/*
a set can contain any element that accepts an identifier of type T
in our case:
- a set is a map from such an identifier to such an element
- the identifier type T is int64
- elements are timestamp structs

Idea 0:
	Turn set into a struct that, in addition to the map,
	contains a field with a sample key element. This 
	would allow us to use Gobra's typeOf operator to
	implement the validElem and validKey predicates.
	--> Easy-ish and good enough for our case
	--> But, doesn't support abstract types, and I'm
		not entirely sure how the operator's semantics
		are defined. It could be that subtypes aren't
		supported either.
*/

type Elem interface {
	pred mem()
	pred validKey(key any)

	requires acc(mem(), _)
	ensures isComparable(res) && validKey(res)
	pure ToComparable() (res any)
}

type Set interface {
	pred mem()
	pred validElem(val Elem)
	pred validKey(key any)

	requires acc(mem(), pSet) && acc(val.mem(), pElem) && validElem(val)
	ensures res.mem() && validElem(res)
	Has(val Elem, ghost pSet perm, ghost pElem perm) (res Elem)

	requires acc(mem(), p) && validKey(key)
	ensures res.mem() && validElem(res)
	HasKey(key any, ghost p perm) (res Elem)

	preserves mem() && acc(val.mem(), p) && validElem(val)
	Add(val Elem, ghost p perm)

	preserves mem() && acc(val.mem(), p) && validElem(val)
	ensures res.mem() && validElem(res)
	Rm(val Elem, ghost p perm) (res Elem)

	requires acc(mem(), p)
	pure Size(ghost p perm) int
}

type internalSet map[any]Elem

type setWithWitness struct {
	witness any
	s internalSet
}

requires isComparable(sample)
pure func MkSet(sample any) (res Set) {
	return &setWithWitness{sample, make(internalSet)}
}

requires acc(sww, pSet) && acc(sww.s, pSet) && acc(val.mem(), pElem) && sww.validElem(val)
ensures res.mem() && sww.validElem(res)
func (sww *setWithWitness) Has(val Elem, ghost pSet perm, ghost pElem perm) (res Elem) {
	return (*sww).s[val.ToComparable()]
}

requires acc(sww, p) && acc(sww.s, p) && sww.validKey(val)
ensures res.mem() && sww.validElem(res)
func (sww *setWithWitness) HasKey(val any, ghost p perm) (res Elem) {
	return (*sww).s[val]
}

preserves acc(sww) && acc(sww.s) && acc(val.mem(), p) && sww.validElem(val)
func (sww *setWithWitness) Add(val Elem, ghost p perm) {
	(*sww).s[val.ToComparable()] = val
}

preserves acc(sww) && acc(sww.s) && acc(val.mem(), p) && sww.validElem(val)
ensures res.mem() && sww.validElem(res)
func (sww *setWithWitness) Rm(val Elem, ghost p perm) (res Elem) {
	e := (*sww).s[val.ToComparable()]
	delete((*sww).s, val.ToComparable())
	return e
}

requires acc(sww, p) && acc(sww.s, p)
pure func (sww *setWithWitness) Size(ghost p perm) int {
	return len((*sww).s)
}

pred (sww *setWithWitness) mem() {
	acc(sww) && acc(sww.s)
}

pred (sww *setWithWitness) validElem(val Elem) {
	acc(val.mem(), _) && val.validKey(sww.witness)
}

pred (sww *setWithWitness) validKey(key any) {
	typeOf(sww.witness) == typeOf(key)
}

(*setWithWitness) implements Set {
	(sww *setWithWitness) Has(val Elem, ghost pSet perm, ghost pElem perm) (res Elem) {
		unfold acc(sww.mem(), pSet)
		res = sww.Has(val, pSet, pElem)
		fold acc(sww.mem(), pSet)
	}

	(sww *setWithWitness) HasKey(key any, ghost p perm) (res Elem) {
		unfold acc(sww.mem(), p)
		res = sww.HasKey(key, p)
		fold acc(sww.mem(), p)
	}

	(sww *setWithWitness) Add(val Elem, ghost p perm) {
		unfold sww.mem()
		sww.Add(val, p)
		fold sww.mem()
	}

	(sww *setWithWitness) Rm(val Elem, ghost p perm) (res Elem) {
		unfold sww.mem()
		res = sww.Rm(val, p)
		fold sww.mem()
	}

	pure (sww *setWithWitness) Size(ghost p perm) int {
		return unfolding acc(sww.mem(), p) in sww.Size(p)
	}
}